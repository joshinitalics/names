<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Smash Fixed-Cam</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Kanit:ital,wght@1,900&display=swap');

        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Kanit', sans-serif; }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 100px;
            pointer-events: none;
            user-select: none;
        }

        .player-card {
            text-align: center;
            min-width: 120px;
        }

        .percent { 
            font-size: 5rem; 
            font-weight: 900; 
            font-style: italic;
            line-height: 1;
            text-shadow: 
                -3px -3px 0 #000,  
                 3px -3px 0 #000,
                -3px  3px 0 #000,
                 3px  3px 0 #000,
                 8px  8px 0 #000; 
        }

        #p1-percent { color: #ff3333; }
        #p2-percent { color: #3333ff; }

        .name { 
            font-size: 1.5rem; 
            color: white; 
            font-weight: 900;
            margin-top: -5px;
            text-shadow: 
                -2px -2px 0 #000,  
                 2px -2px 0 #000,
                -2px  2px 0 #000,
                 2px  2px 0 #000,
                 4px  4px 0 #000;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            line-height: 1.4;
            font-family: sans-serif;
            z-index: 10;
        }
        .key-hint { background: #444; padding: 2px 6px; border-radius: 4px; font-family: monospace; }
        
        .toggle-container {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            pointer-events: auto;
        }
    </style>
</head>
<body>

    <div id="instructions">
        <p><strong>P1 (Red):</strong> <span class="key-hint">S/T</span> L/R, <span class="key-hint">R/H</span> U/D, <span class="key-hint">Space</span> Jump</p>
        <p><strong>Attacks:</strong> <span class="key-hint">N</span> Light, <span class="key-hint">E</span> Heavy</p>
        
        <label class="toggle-container">
            <input type="checkbox" id="hitbox-toggle">
            <span>Show Hitboxes</span>
        </label>

        <div class="mt-2 border-t border-white/20 pt-2 text-xs opacity-80">
            <p><strong>Physics:</strong> Gravity set to -0.03. Aerial down KB reduced.</p>
        </div>
    </div>

    <div id="ui">
        <div class="player-card" id="p1-card">
            <div class="percent" id="p1-percent">0%</div>
            <div class="name">P1</div>
        </div>
        <div class="player-card" id="p2-card">
            <div class="percent" id="p2-percent">0%</div>
            <div class="name">CPU</div>
        </div>
    </div>

    <script>
        const STAGE_WIDTH = 24;
        const STAGE_HEIGHT = 2;
        const GRAVITY = -0.03;
        const TERMINAL_VELOCITY = -0.85; 
        const GROUND_FRICTION = 0.82; 
        const AIR_FRICTION = 0.985;   
        const BLAST_ZONE_X = 40;
        const BLAST_ZONE_Y = 30;
        const MAX_WALK_SPEED = 0.20;  
        const MAX_AIR_CONTROL = 0.12; 
        const MOVE_ACCEL_GROUND = 0.04;
        const MOVE_ACCEL_AIR = 0.016;
        const HITSTUN_CONTROL_MULT = 0.4;
        const HITSTUN_LOCKOUT = 15;    
        const KB_COEFFICIENT = 0.01; 

        let scene, camera, renderer;
        let players = [];
        let keys = {};
        let effects = []; 
        let globalHitstop = 0; 
        let showHitboxes = false;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 40);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(10, 20, 10);
            sun.castShadow = true;
            scene.add(sun);

            const stageGeo = new THREE.BoxGeometry(STAGE_WIDTH, STAGE_HEIGHT, 8);
            const stageMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const stage = new THREE.Mesh(stageGeo, stageMat);
            stage.receiveShadow = true;
            scene.add(stage);

            players.push(createPlayer(0xff3333, -5, "p1", false));
            players.push(createPlayer(0x3333ff, 5, "p2", true));

            // Setup UI listeners
            document.getElementById('hitbox-toggle').addEventListener('change', (e) => {
                showHitboxes = e.target.checked;
            });

            window.addEventListener('keydown', e => {
                const code = e.code;
                players.forEach(p => {
                    if (p.isAI || globalHitstop > 0) return;
                    if (code === 'Space' && p.hitstun <= 0) performJump(p, keys['KeyS'], keys['KeyT']);
                    if ((code === 'KeyN' || code === 'KeyE') && !p.attacking && p.hitstun <= 0) {
                        const dir = {
                            x: (keys['KeyT'] ? 1 : (keys['KeyS'] ? -1 : 0)),
                            y: (keys['KeyR'] ? 1 : (keys['KeyH'] ? -1 : 0))
                        };
                        handleAttackInput(p, dir, code === 'KeyN' ? 'light' : 'heavy');
                    }
                });
                keys[code] = true;
            });
            
            window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createPlayer(color, startX, id, isAI) {
            const group = new THREE.Group();
            const visualBody = new THREE.Group();
            const bodyGeo = new THREE.BoxGeometry(1.2, 1.8, 1.2);
            const bodyMat = new THREE.MeshPhongMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            visualBody.add(body);

            const eyeGeo = new THREE.BoxGeometry(0.8, 0.2, 0.2);
            const eyeMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const eyes = new THREE.Mesh(eyeGeo, eyeMat);
            eyes.position.set(0, 0.4, 0.61);
            visualBody.add(eyes);
            group.add(visualBody);

            const hitboxContainer = new THREE.Group();
            group.add(hitboxContainer);

            scene.add(group);

            return {
                id: id,
                isAI: isAI,
                mesh: group,
                visualBody: visualBody,
                hitboxContainer: hitboxContainer,
                color: color,
                velocity: new THREE.Vector3(),
                pos: new THREE.Vector3(startX, 5, 0),
                percent: 0,
                isGrounded: false,
                jumpsUsed: 0,
                facing: (startX < 0 ? 1 : -1),
                attacking: false,
                currentAttack: null, 
                hitstun: 0,
                hitstunMax: 0, 
                width: 1.2,
                height: 1.8
            };
        }

        function performJump(p, moveLeft, moveRight) {
            if (p.isGrounded) {
                p.velocity.y = 0.6; 
                p.isGrounded = false;
                p.jumpsUsed = 1;
            } else if (p.jumpsUsed < 2) {
                p.velocity.y = 0.55;
                p.jumpsUsed = 2;
                if (moveLeft) p.velocity.x = -0.15;
                if (moveRight) p.velocity.x = 0.15;
            }
        }

        function handleAttackInput(player, dir, type) {
            player.attacking = true;
            const attackDirY = dir.y;

            let attackConfig = {
                startup: 0,
                activeFrames: 10,
                range: 2.0,
                damage: 5,
                knockback: 10,
                angle: 60,
                offset: new THREE.Vector3(1.2, 0, 0), 
                type: type,
                hasHit: false,
                visual: null
            };

            if (player.isGrounded) {
                if (type === 'light') {
                    attackConfig.startup = 50; 
                    attackConfig.damage = 3;
                    attackConfig.knockback = 5;
                    attackConfig.activeFrames = 8;
                    if (attackDirY === 1) { attackConfig.angle = 80; attackConfig.offset.set(0, 1.8, 0); attackConfig.range = 1.8; }
                    else if (attackDirY === -1) { attackConfig.angle = 45; attackConfig.offset.set(1.0, -0.6, 0); attackConfig.range = 1.8; }
                    else { attackConfig.angle = 60; attackConfig.offset.set(1.2, 0, 0); attackConfig.range = 1.4; }
                } else { 
                    attackConfig.startup = 100;
                    attackConfig.damage = 12;
                    attackConfig.knockback = 6; 
                    attackConfig.activeFrames = 15;
                    if (attackDirY === 1) { 
                        attackConfig.angle = 60; 
                        attackConfig.offset.set(0, 2.2, 0); 
                        attackConfig.range = 2.0; 
                    }
                    else if (attackDirY === -1) { attackConfig.startup = 150; attackConfig.angle = 45; attackConfig.offset.set(1.2, -0.6, 0); attackConfig.range = 1.8; }
                    else { attackConfig.angle = 45; attackConfig.offset.set(1.6, 0, 0); attackConfig.range = 2.2; }
                }
            } else {
                attackConfig.type = 'light';
                attackConfig.activeFrames = 12;
                attackConfig.startup = 40;
                attackConfig.damage = 4;
                attackConfig.knockback = 4;
                if (attackDirY === -1) { 
                    attackConfig.angle = 30; 
                    attackConfig.knockback = 2; 
                    attackConfig.offset.set(0, -1.8, 0); 
                    attackConfig.range = 1.8; 
                } else { 
                    attackConfig.angle = 60;
                    attackConfig.offset.set(0.8, 0, 0); 
                    attackConfig.range = 1.5; 
                }
            }

            if (type === 'light' || !player.isGrounded) player.visualBody.scale.set(0.9, 1.1, 0.9);
            else player.visualBody.scale.set(0.8, 1.2, 0.8);

            setTimeout(() => {
                if (player.hitstun > 0 || globalHitstop > 0) return;
                player.visualBody.scale.set(1, 1, 1);
                
                const isHeavyGround = (type === 'heavy' && player.isGrounded);
                const hitColor = isHeavyGround ? 0xff0000 : 0xffff00;
                const geo = new THREE.SphereGeometry(attackConfig.range, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: hitColor, 
                    transparent: true, 
                    opacity: showHitboxes ? 0.4 : 0.0,
                    depthWrite: false
                });
                const visualMesh = new THREE.Mesh(geo, mat);
                
                visualMesh.position.set(attackConfig.offset.x * player.facing, attackConfig.offset.y, attackConfig.offset.z);
                
                player.hitboxContainer.add(visualMesh);
                attackConfig.visual = visualMesh;
                player.currentAttack = attackConfig;
            }, attackConfig.startup);
        }

        function clearAttack(player) {
            if (player.currentAttack && player.currentAttack.visual) {
                player.hitboxContainer.remove(player.currentAttack.visual);
            }
            player.attacking = false;
            player.currentAttack = null;
            player.visualBody.scale.set(1, 1, 1);
        }

        const worldHitboxPos = new THREE.Vector3();

        function checkHit(player, config) {
            if (!config || config.hasHit || !config.visual) return;
            const opponent = players.find(p => p !== player);
            config.visual.getWorldPosition(worldHitboxPos);

            const minX = opponent.pos.x - 0.6;
            const maxX = opponent.pos.x + 0.6;
            const minY = opponent.pos.y - 0.9;
            const maxY = opponent.pos.y + 0.9;

            const closestX = Math.max(minX, Math.min(worldHitboxPos.x, maxX));
            const closestY = Math.max(minY, Math.min(worldHitboxPos.y, maxY));
            const dx = worldHitboxPos.x - closestX;
            const dy = worldHitboxPos.y - closestY;

            const squaredDistance = dx * dx + dy * dy;
            const inRange = squaredDistance < (config.range * config.range);

            if (inRange && opponent.hitstun <= 0) {
                config.hasHit = true; 
                const kbDir = opponent.pos.x - player.pos.x > 0 ? 1 : -1;
                
                const pctFactor = Math.min(1, opponent.percent / 100);
                let hitstopFrames = 0;
                if (config.type === 'light') {
                    hitstopFrames = 2 + Math.floor(8 * pctFactor);
                } else {
                    hitstopFrames = 8 + Math.floor(12 * pctFactor);
                }
                
                globalHitstop = hitstopFrames;
                applyHit(opponent, kbDir, config);
                if (showHitboxes) {
                    config.visual.material.opacity = 0.8;
                }
            }
        }

        function applyHit(victim, xDir, config) {
            victim.percent += config.damage;
            document.getElementById(`${victim.id}-percent`).innerText = victim.percent + "%";
            const rad = config.angle * (Math.PI / 180);
            const forceMultiplier = 1.0 + (victim.percent * 0.012);
            const totalForce = config.knockback * KB_COEFFICIENT * forceMultiplier;
            
            victim.velocity.x = Math.cos(rad) * xDir * totalForce * 6;
            victim.velocity.y = Math.sin(rad) * totalForce * 6;

            const baseHitstun = config.type === 'heavy' ? 10 : 5;
            victim.hitstun = Math.min(60, baseHitstun + (victim.percent * 0.08));
            victim.hitstunMax = victim.hitstun;
            
            victim.isGrounded = false;
            if (victim.attacking) clearAttack(victim);
            
            victim.visualBody.children[0].material.emissive.setHex(0xffffff);
            setTimeout(() => victim.visualBody.children[0].material.emissive.setHex(0x000000), 100);
        }

        function createKOEffect(pos, color) {
            const geo = new THREE.SphereGeometry(5, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1.0 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            scene.add(mesh);
            effects.push({
                mesh, life: 1.0,
                update: function(dt) {
                    this.life -= dt * 1.5;
                    this.mesh.scale.multiplyScalar(1.2);
                    this.mesh.material.opacity = this.life;
                    if (this.life <= 0) { scene.remove(this.mesh); return false; }
                    return true;
                }
            });
        }

        function handleInput() {
            if (globalHitstop > 0) return;

            players.forEach(p => {
                if (p.attacking && p.isGrounded) return;

                let moveLeft = false;
                let moveRight = false;

                if (p.isAI) {
                    const halfW = STAGE_WIDTH / 2;
                    if (p.pos.x > halfW) {
                        moveLeft = true;
                        if (p.pos.y < 5 && p.velocity.y < 0 && p.jumpsUsed < 2 && p.hitstun <= 0) performJump(p, true, false);
                    } else if (p.pos.x < -halfW) {
                        moveRight = true;
                        if (p.pos.y < 5 && p.velocity.y < 0 && p.jumpsUsed < 2 && p.hitstun <= 0) performJump(p, false, true);
                    } else {
                        moveLeft = p.pos.x > 2;
                        moveRight = p.pos.x < -2;
                    }
                } else {
                    moveLeft = keys['KeyS'];
                    moveRight = keys['KeyT'];
                }

                let accel = p.isGrounded ? MOVE_ACCEL_GROUND : MOVE_ACCEL_AIR;
                let max = p.isGrounded ? MAX_WALK_SPEED : MAX_AIR_CONTROL;

                if (p.hitstun > 0) {
                    const elapsed = p.hitstunMax - p.hitstun;
                    if (elapsed < HITSTUN_LOCKOUT) {
                        accel = 0; 
                        max = 0;
                    } else {
                        accel *= HITSTUN_CONTROL_MULT;
                        max *= HITSTUN_CONTROL_MULT;
                    }
                }

                if (moveLeft) { p.velocity.x -= accel; p.facing = -1; }
                if (moveRight) { p.velocity.x += accel; p.facing = 1; }

                if (Math.abs(p.velocity.x) > max && p.hitstun <= 0) {
                    p.velocity.x = THREE.MathUtils.lerp(p.velocity.x, Math.sign(p.velocity.x) * max, 0.2);
                }
            });
        }

        function updatePhysics(dt) {
            effects = effects.filter(fx => fx.update(dt));

            if (globalHitstop > 0) {
                globalHitstop--;
                players.forEach(p => {
                    if (p.hitstun > 0 || (p.currentAttack && p.currentAttack.hasHit)) {
                        p.visualBody.position.set(
                            (Math.random() - 0.5) * 0.3,
                            (Math.random() - 0.5) * 0.3,
                            0
                        );
                    }
                });
                return;
            }

            players.forEach(p => {
                p.visualBody.position.set(0, 0, 0);

                if (p.currentAttack) {
                    checkHit(p, p.currentAttack);
                    p.currentAttack.activeFrames--;
                    
                    if (p.currentAttack.visual) {
                        if (showHitboxes) {
                            p.currentAttack.visual.material.opacity = Math.max(0.1, p.currentAttack.visual.material.opacity * 0.95);
                        } else {
                            p.currentAttack.visual.material.opacity = 0;
                        }
                    }

                    if (p.currentAttack.activeFrames <= 0) clearAttack(p);
                }

                if (p.hitstun > 0) p.hitstun--;
                else p.hitstunMax = 0;

                p.velocity.y = Math.max(TERMINAL_VELOCITY, p.velocity.y + GRAVITY);
                p.pos.add(p.velocity);
                p.velocity.x *= p.isGrounded ? GROUND_FRICTION : AIR_FRICTION;

                const halfW = STAGE_WIDTH / 2;
                if (p.pos.x > -halfW - 0.6 && p.pos.x < halfW + 0.6) {
                    if (p.pos.y <= 1 + (p.height / 2) && p.pos.y > 0 && p.velocity.y < 0) {
                        p.pos.y = 1 + (p.height/2);
                        p.velocity.y = 0;
                        if (!p.isGrounded) { p.isGrounded = true; p.jumpsUsed = 0; }
                    }
                } else p.isGrounded = false;

                if (Math.abs(p.pos.x) > BLAST_ZONE_X || Math.abs(p.pos.y) > BLAST_ZONE_Y) {
                    createKOEffect(p.pos.clone(), p.color);
                    respawn(p);
                }

                p.mesh.position.copy(p.pos);
                const targetRot = p.facing === 1 ? Math.PI / 2 : -Math.PI / 2;
                p.visualBody.rotation.y = THREE.MathUtils.lerp(p.visualBody.rotation.y, targetRot, 0.2);
            });
        }

        function respawn(player) {
            player.pos.set(player.id === 'p1' ? -5 : 5, 12, 0);
            player.velocity.set(0, 0, 0);
            player.percent = 0;
            player.hitstun = 0;
            player.hitstunMax = 0;
            player.jumpsUsed = 0;
            if (player.attacking) clearAttack(player);
            document.getElementById(`${player.id}-percent`).innerText = "0%";
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            handleInput();
            updatePhysics(clock.getDelta());
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>